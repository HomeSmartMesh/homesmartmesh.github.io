---
import { exists } from '../../libs/utils.js'
import { config } from '../../../config.js'

export interface Props {
  src: string; // URL to original image
  rel: string; // relative path inside content dir (e.g. "room_view_bot/img.jpg")
  dirpath: string; // content section dirpath
  width?: number;
  height?: number;
  alt?: string;
  title?: string;
  class?: string;
  sizes?: string; // optional override
  masonry?: boolean; // used to compute default sizes
  loading?: 'lazy' | 'eager';
  decoding?: 'async' | 'sync' | 'auto';
}

const {
  src,
  rel,
  dirpath,
  width,
  height,
  alt = '',
  title = '',
  class: className = '',
  sizes: sizesProp,
  masonry = false,
  loading = 'lazy',
  decoding = 'async',
} = Astro.props as Props;

// Determine candidate target widths based on original dimensions
const originalW = width ?? 0;
let candidateWidths: number[] = [];
if (originalW > 0) {
  if (originalW > 1280) candidateWidths.push(640);
  if (originalW > 640) candidateWidths.push(320);
} else {
  // If original width is unknown, optimistically probe common sizes
  candidateWidths = [640, 320];
}

// Map rel (inside dirpath) to sizes path: first segment gets _sizes suffix
// Build public/images relative dir and base name from dirpath + rel
function getImageRelParts(dirpath: string, relPath: string): { dirRel: string; name: string } {
  const relNorm = relPath.replaceAll('\\','/');
  const dirNorm = dirpath.replaceAll('\\','/');
  const lastSlash = relNorm.lastIndexOf('/');
  const relDir = lastSlash >= 0 ? relNorm.slice(0, lastSlash) : '';
  const file = lastSlash >= 0 ? relNorm.slice(lastSlash + 1) : relNorm;
  const dot = file.lastIndexOf('.');
  const base = dot >= 0 ? file.slice(0, dot) : file;
  const dirRel = relDir ? `${dirNorm}/${relDir}` : dirNorm;
  return { dirRel, name: base };
}

// Probe filesystem for available WebP variants and build srcset
const variants: Array<{ w: number; url: string }> = [];
if (candidateWidths.length && rel) {
  const { dirRel, name } = getImageRelParts(dirpath, rel);
  for (const w of candidateWidths.sort((a,b)=>a-b)) {
    const relInImages = `${dirRel ? dirRel + '/' : ''}${name}-${w}.webp`;
    const absCandidate = `${config.rootdir}/public/images/${relInImages}`.replaceAll('\\','/');
    if (await exists(absCandidate)) {
      const url = `${config.base}/images/${relInImages}`.replaceAll('\\','/');
      variants.push({ w, url });
    }
  }
}

const hasVariants = variants.length > 0;
const srcset = hasVariants ? variants.map(v => `${v.url} ${v.w}w`).join(', ') : undefined;

function defaultSizes(masonry: boolean): string {
  return masonry
    ? '(max-width: 600px) 100vw, 20rem'
    : '(max-width: 700px) 100vw, (max-width: 1100px) 33vw, 25vw';
}

const sizesAttr = sizesProp ?? defaultSizes(masonry);
---
{hasVariants ? (
  <picture class={className}>
    <source type="image/webp" srcset={srcset} sizes={sizesAttr} />
    <img src={src} width={width} height={height} alt={alt} title={title} loading={loading} decoding={decoding} />
  </picture>
) : (
  <img class={className} src={src} width={width} height={height} alt={alt} title={title} loading={loading} decoding={decoding} />
)}

<style>
:global(picture), :global(img) {
  display: block;
  width: 100%;
  height: 100%;
}
:global(img) {
  object-fit: cover;
}
</style>
